[
  {
    "skill": "---\nname: fla-api\ndescription: \"Guidance for API-layer responsibilities: external communication boundaries and transport-level error handling.\"\n---\n\n<Purpose>\nDefine `_apis` as the sole boundary for external systems and transport-level concerns.\n</Purpose>\n\n<Use_When>\n- Effective layer resolved to `_apis`.\n- Task focuses on external I/O such as HTTP requests, storage, cookies, or transport mapping.\n</Use_When>\n\n<Layer_Intent>\nAPI layer handles communication with external systems (server, localStorage, cookies, and related transport concerns).\n</Layer_Intent>\n\n<Rules>\n1. Keep transport code and protocol/error handling in this layer.\n2. Return predictable outputs to state/container callers.\n3. Do not place UI rendering decisions in API modules.\n</Rules>\n\n<Conceptual_Examples>\nServer request with status-based handling:\n```ts\n// File: _pages/user/_apis/user/user.tsx\nexport const fetchUser = async (...) => {\n  try {\n    const result = await axios.get(...);\n    return result;\n  } catch (error) {\n    if (isAxiosError(error) && error.response?.status === 404) {\n      return undefined;\n    }\n    throw error;\n  }\n};\n```\n\nBrowser localStorage access:\n```ts\n// File: _pages/user/_apis/user/user.ts\nexport const fetchUserSetting = async (...) => {\n  try {\n    const settings = window.localStorage.getItem(\"settings\") || {};\n    return settings ? JSON.parse(settings) : { theme: \"light\" };\n  } catch {\n    return { theme: \"light\" };\n  }\n};\n```\n</Conceptual_Examples>\n"
  },
  {
    "skill": "---\nname: fla-architecture\ndescription: Use for every task first; then route to path- or keyword-matched skills (fla-file-directory-convention, fla-layer-resolver, and one layer skill).\n---\n\n<Purpose>\nProvide the complete base architecture contract for this repository so agents can work without external docs.\n</Purpose>\n\n<Use_When>\n- Always, for every implementation/refactor task.\n- Before activating any other repository skill.\n- When task scope is unclear and a base architecture decision is needed.\n</Use_When>\n\n<Architecture_Overview>\nFractal Layered Architecture (FLA) is a frontend architecture approach designed for stable growth under changing business requirements.\n\nIts core idea is responsibility isolation through one-way layer direction. This limits blast radius when failures happen and makes root-cause localization faster.\n</Architecture_Overview>\n\n<Layer_Direction>\nAllowed direction (left to right):\n`_pages -> _containers -> _states -> _components -> _apis -> _utils`\n\nRules:\n- Lower layers must not reference upper layers.\n- Upper layers may access lower layers.\n</Layer_Direction>\n\n<Nested_Layers>\nLayers may contain nested sub-layers for strong cohesion and easier feature moves/deletions.\n\nExample:\n```bash\n└── _pages\n    └── profile\n        ├── profile.tsx\n        └── _containers\n            └── user\n                ├── _components\n                │   ├── avatar\n                │   └── info\n                ├── _states\n                └── _apis\n```\n</Nested_Layers>\n\n<Layer_Roles>\n1. Pages: browser-facing behavior (routing, host objects), high-level feature orchestration.\n2. Containers: compose UI blocks and decide rendering by data status.\n3. States: state/query/mutation modules and business rules.\n4. Components: pure/presentational UI using props and local UI state.\n5. APIs: external communication boundary (HTTP/storage/cookies/etc.).\n6. Utils: lowest independent helpers and undefined misc utilities.\n</Layer_Roles>\n\n<Naming_Conventions>\n1. Use kebab-case for file and directory names.\n2. Prefix layer directories with underscore (`_`).\n3. Use suffix file splits when needed (`.stories`, `.schema`, `.type`, `.test`).\n</Naming_Conventions>\n\n<Code_Writing_Principles>\n1. Prefer small local duplication over premature abstraction.\n2. Split into lower layers gradually as complexity/reuse increases.\n3. If a nested module is used by two or more upper modules, consider moving it upward.\n</Code_Writing_Principles>\n\n\n<Skill_Routing_Links>\nOpen additional skills only when needed:\n\n- `skills/fla-file-directory-convention/SKILL.md`\n  - Read when creating/moving/renaming files or changing module layout.\n- `skills/fla-layer-resolver/SKILL.md`\n  - Read when path includes layers or nested layers and one effective layer must be selected.\n- `skills/fla-page/SKILL.md`\n  - Read for `/_pages/` paths or router/navigation/page orchestration tasks.\n- `skills/fla-container/SKILL.md`\n  - Read for `/_containers/` paths or UI status-branch composition tasks.\n- `skills/fla-state/SKILL.md`\n  - Read for `/_states/` paths or query/mutation/state-business tasks.\n- `skills/fla-component/SKILL.md`\n  - Read for `/_components/` paths or presentational prop-driven UI tasks.\n- `skills/fla-api/SKILL.md`\n  - Read for `/_apis/` paths or HTTP/fetch/axios/storage/cookie tasks.\n- `skills/fla-util/SKILL.md`\n  - Read for `/_utils/` paths or pure utility/helper tasks.\n</Skill_Routing_Links>\n\n<Execution_Policy>\n- Apply this skill first.\n- Then apply `fla-file-directory-convention` for path/structure changes.\n- Then apply one resolved layer skill via `fla-layer-resolver`.\n- If rules conflict, this global skill wins unless a deeper explicit layer rule overrides behavior within its own layer scope.\n</Execution_Policy>\n"
  },
  {
    "skill": "---\nname: fla-component\ndescription: \"Guidance for component-layer responsibilities: prop-driven presentational UI with minimal external coupling.\"\n---\n\n<Purpose>\nDefine `_components` as pure/presentational units with minimal external coupling.\n</Purpose>\n\n<Use_When>\n- Effective layer resolved to `_components`.\n- Task focuses on rendering behavior, props/callbacks, or local UI state boundaries.\n</Use_When>\n\n<Layer_Intent>\nComponent layer should not internally rely on external state values. It should use injected properties and optional local UI state.\n</Layer_Intent>\n\n<Rules>\n1. Keep rendering deterministic from props/local state.\n2. Keep business decisions and external data access out of component internals.\n3. Pass events upward through callbacks.\n</Rules>\n\n<Conceptual_Example>\n```tsx\n// File: _pages/user/_containers/user/_components/profile/user.tsx\nexport const Profile: React.FC = ({ id, name, age }) => {\n  const [isDetailShow, setIsDetailShow] = useState(false);\n\n  return (\n    <div>\n      <button type=\"button\" onClick={() => setIsDetailShow((prev) => !prev)}>\n        id: {id}\n      </button>\n      {isDetailShow && (\n        <>\n          <p>name: {name}</p>\n          <p>age: {age}</p>\n        </>\n      )}\n    </div>\n  );\n};\n```\n</Conceptual_Example>\n"
  },
  {
    "skill": "---\nname: fla-container\ndescription: \"Guidance for container-layer responsibilities: composing UI modules and handling state-driven rendering decisions.\"\n---\n\n<Purpose>\nDefine `_containers` as composition units that bridge state outputs to component rendering.\n</Purpose>\n\n<Use_When>\n- Effective layer resolved to `_containers`.\n- Task focuses on screen composition or loading/error/empty/success branching.\n</Use_When>\n\n<Layer_Intent>\nContainers compose screens using components, fetch needed data via state hooks, and decide what to render by processing status.\n</Layer_Intent>\n\n<Rules>\n1. Handle loading/error/success/empty branches in container scope.\n2. Use state hooks from `_states` for data lifecycle.\n3. Pass browser actions in from pages via callbacks.\n4. Keep transport details out of container implementations.\n</Rules>\n\n<Conceptual_Example>\n```tsx\n// File: _pages/user/_containers/user/user.tsx\nimport { Profile } from \"./_components/profile/profile.tsx\";\nimport { useUserFetch } from \"./_states/user/user.ts\";\n\nexport const User: React.FC = ({ onSignInClick }) => {\n  const { data, isFetching, isError } = useUserFetch();\n\n  if (isFetching) return <div>Fetching data...</div>;\n  if (isError) return <div>An error occurred while processing data.</div>;\n\n  return !!data ? <Profile data={data} /> : <button onClick={onSignInClick}>Login</button>;\n};\n```\n</Conceptual_Example>\n"
  },
  {
    "skill": "---\nname: fla-file-directory-convention\ndescription: Use when creating/moving/renaming files or folders, or when deciding naming, module grouping, and suffix split rules.\n---\n\n<Purpose>\nEmbed the complete file/directory policy so agents can create and reorganize modules consistently without external references.\n</Purpose>\n\n<Use_When>\n- Creating, renaming, moving, or deleting files/directories.\n- Changing module grouping style or introducing new module files.\n- Task mentions naming, folder structure, kebab-case, suffixes, or file conventions.\n</Use_When>\n\n<Rules>\n1. File and directory names use kebab-case (lowercase + hyphen).\n2. Layer directories use underscore prefix:\n   - `_pages`, `_containers`, `_states`, `_components`, `_apis`, `_utils`\n3. Split concerns with suffix files where useful:\n   - `.stories.ts`, `.schema.ts`, `.type.ts`, `.test.ts`\n   - Additional suffixes are allowed by team agreement.\n</Rules>\n\n<Module_Grouping>\nA layer directory must choose one style and stay consistent:\n\nA) Directory-based module grouping\n```bash\n└── _pages\n    └── main\n        ├── main.tsx\n        └── main.type.ts\n    └── account\n        ├── account.tsx\n        └── account.type.ts\n```\n\nB) File-based module grouping\n```bash\n└── _pages\n    ├── main.tsx\n    ├── main.type.ts\n    ├── account.tsx\n    └── account.type.ts\n```\n\nConstraint:\n- If a module has nested sub-layers, directory-based grouping is required for that module.\n</Module_Grouping>\n\n<Suffix_Separation_Examples>\n```ts\n// _apis/account/account.schema.ts\nexport const AccountSchema = z.object({...});\n```\n\n```ts\n// _apis/account/account.type.ts\nimport { AccountSchema } from \"./account.schema.ts\";\nexport type Account = z.infer<typeof AccountSchema>;\n```\n</Suffix_Separation_Examples>\n\n<Execution_Policy>\n- Keep local layer consistency first.\n- Do not mix grouping strategies in the same layer directory unless performing a full migration.\n</Execution_Policy>\n"
  },
  {
    "skill": "---\nname: fla-layer-resolver\ndescription: Use when target path contains one or more FLA layer segments; pick the deepest segment and activate exactly one layer skill.\n---\n\n<Purpose>\nPrevent ambiguous multi-layer guidance by selecting one effective layer skill per target path.\n</Purpose>\n\n<Use_When>\n- A path includes one or more of `_pages`, `_containers`, `_states`, `_components`, `_apis`, `_utils`.\n- Nested feature paths contain multiple layer segments.\n- Task asks which layer skill should be applied.\n</Use_When>\n\n<Algorithm>\n1. Parse path segments.\n2. Extract all recognized layer segments.\n3. Choose the deepest (last) matching segment.\n4. Activate exactly one layer skill:\n   - `_pages` -> `fla-page`\n   - `_containers` -> `fla-container`\n   - `_states` -> `fla-state`\n   - `_components` -> `fla-component`\n   - `_apis` -> `fla-api`\n   - `_utils` -> `fla-util`\n5. Always combine with:\n   - `fla-architecture` (required)\n   - `fla-file-directory-convention` (when path/structure changes occur)\n</Algorithm>\n\n<Examples>\n- `src/_pages/user/_containers/user/_components/avatar/avatar.tsx` -> `fla-component`\n- `src/_pages/user/_containers/user/user.tsx` -> `fla-container`\n- `src/_pages/user/user.tsx` -> `fla-page`\n- `src/_utils/date/formatter.ts` -> `fla-util`\n- no layer segment -> no layer skill (global + file-directory only)\n</Examples>\n"
  },
  {
    "skill": "---\nname: fla-page\ndescription: Guidance for page-layer responsibilities including browser interaction, routing ownership, and top-level orchestration.\n---\n\n<Purpose>\nDefine how `_pages` should host browser interaction and orchestrate lower layers.\n</Purpose>\n\n<Use_When>\n- Effective layer resolved to `_pages`.\n- Task requires page-level orchestration or browser/routing ownership decisions.\n</Use_When>\n\n<Layer_Intent>\nThe page layer includes browser-interactive features (host objects, navigation functions).\n\nRecommended approach:\n- Implement business behavior in pages first when building quickly.\n- Split into lower layers incrementally as complexity and reuse increase.\n</Layer_Intent>\n\n<Rules>\n1. Browser routing/navigation remains page-owned.\n2. Pages compose containers/components/state hooks as orchestration entry points.\n3. Do not force early decomposition if the feature is still small.\n4. When decomposition starts, keep routing callbacks in page and pass callbacks downward.\n</Rules>\n\n<Conceptual_Example>\nInitial page-first implementation:\n```tsx\n// File: _pages/user/user.tsx\nimport { Profile } from \"./_components/profile/profile.tsx\";\n\nexport const User: React.FC = () => {\n  const router = useRouter();\n  const { data } = useUserFetch();\n  const handleSignInClick = () => router.replace(\"/sign-in\");\n  return !!data ? <Profile data={data} /> : <button onClick={handleSignInClick}>Login</button>;\n};\n```\n\nAfter refactoring to container:\n```tsx\n// File: _pages/user/user.tsx\nimport { User as UserContainer } from \"./_containers/profile/profile.tsx\";\n\nexport const User: React.FC = () => {\n  const router = useRouter();\n  const handleSignInClick = () => router.replace(\"/sign-in\");\n  return <UserContainer onSignInClick={handleSignInClick} />;\n};\n```\n</Conceptual_Example>\n"
  },
  {
    "skill": "---\nname: fla-state\ndescription: Guidance for state-layer responsibilities including query and mutation orchestration, state logic, and business validation around data flow.\n---\n\n<Purpose>\nDefine `_states` as the place for application state behavior and business logic around data operations.\n</Purpose>\n\n<Use_When>\n- Effective layer resolved to `_states`.\n- Task focuses on hooks, cache/state behavior, or request/response business rules.\n</Use_When>\n\n<Layer_Intent>\nState layer composes modules with state-management tools (React Query, Zustand, etc.) and handles request/response business handling.\n</Layer_Intent>\n\n<Rules>\n1. Implement fetch/update orchestration through hooks or state modules.\n2. Perform validation/condition checks around API calls.\n3. Expose stable outputs for upper layers.\n4. Keep direct browser-routing ownership outside this layer.\n</Rules>\n\n<Conceptual_Examples>\nData query/update hooks:\n```ts\n// File: _pages/user/_states/user/user.ts\nimport { fetchUser, updateUser } from \"./_apis/user/user.ts\";\n\nexport const useUserFetch = () =>\n  useQuery({\n    queryFn: async () => {\n      const result = await fetchUser();\n      return result;\n    },\n  });\n\nexport const useUserUpdate = () =>\n  useMutation({\n    mutationFn: async (data) => {\n      await updateUser(data);\n    },\n  });\n```\n\nState hook using lower component:\n```tsx\n// File: _states/dialog/dialog.tsx\nimport { Dialog } from \"/_components/dialog/dialog.tsx\";\n\nexport const useDialog = () => {\n  const [content, setContent] = useState(null);\n  const [isOpen, setIsOpen] = useState(false);\n\n  return {\n    showDialog: (next) => {\n      setContent(next);\n      setIsOpen(true);\n    },\n    closeDialog: () => {\n      setIsOpen(false);\n      setContent(null);\n    },\n    dialogComponent: <Dialog open={isOpen}>{content}</Dialog>,\n  };\n};\n```\n</Conceptual_Examples>\n"
  },
  {
    "skill": "---\nname: fla-util\ndescription: Guidance for util-layer responsibilities including pure, reusable, domain-agnostic helper functions.\n---\n\n<Purpose>\nDefine `_utils` as independent helper space for pure, reusable, non-domain-specific functions.\n</Purpose>\n\n<Use_When>\n- Effective layer resolved to `_utils`.\n- Task focuses on low-level helpers such as formatting, parsing, validation, or reusable utility logic.\n</Use_When>\n\n<Layer_Intent>\nUtil layer is for functions not tied to specific domain behavior (date formatting, regex validation, etc.).\n\nIf additional layers are needed, they may be introduced by team agreement, while preserving one-way direction.\n</Layer_Intent>\n\n<Rules>\n1. Keep utilities independent from upper layers (`_pages`, `_containers`, `_states`, `_components`, `_apis`).\n2. Prefer pure input/output behavior.\n3. Avoid over-fragmenting architecture unless clear value exists.\n</Rules>\n\n<Conceptual_Example>\n```ts\n// File: _utils/date/formatter.ts\nimport { format } from \"date-fns\";\n\nexport const toYMD = (date: Date | number): string => {\n  if (!date) return \"\";\n  return format(date, \"yyyy-MM-dd\");\n};\n```\n</Conceptual_Example>\n"
  }
]
